# CLAUDE.md

## 🚨🔥💀 PROJECT OVERVIEW 🚨🔥💀

**PROJECT NAME:** YOURABSOLUTELYRIGHT.COM
**PROJECT TYPE:** E-commerce merch site
**CONCEPT:** Selling products with "You're absolutely right." - the phrase Claude AI always says
**STACK:** React (Frontend) + Node.js/Express (Backend) + Stripe (Payments) + Printful (Print-on-Demand)
**TOOLS:** Claude Code, GitHub Desktop
**DESIGN AESTHETIC:** Old raggedy look matching Claude Code's color palette (warm beiges/tans with dark brown text)
**GIT WORKFLOW:** User commits manually via GitHub Desktop - DO NOT AUTO-COMMIT

### PROJECT GOALS:
- Build a fully functional e-commerce site that sells Claude-themed merchandise
- Products feature the phrase "You're absolutely right." on mugs, t-shirts, hoodies, etc.
- Automated order fulfillment through Printful integration
- Stripe payment processing
- Clean, humorous, minimalist design

### KEY FEATURES:
- Hero section with "You're" text and subtle Claude logo background
- Horizontal scrolling product carousel
- One-click Stripe checkout
- Automated order creation in Printful via webhooks
- Responsive design (mobile, tablet, desktop)
- Success/cancel pages after checkout

---

## 🚨⚡💥 MANDATORY ACTIVATION PROTOCOL 🚨🔥💀

### **ACTIVATION TRIGGER**:

**When "read claude.md and understand" is detected, ALL PROTOCOLS ACTIVATE with MAXIMUM INTENSITY** 🌌💫⚡

**MANDATORY ACTIVATION SEQUENCE:**

1. 🔍⚡ **SEARCH PROTOCOL** - Comprehensive search before any action
2. 🧠💫 **INTELLIGENCE PROTOCOL** - Evidence-based reasoning
3. 📝✨ **TODO PROTOCOL** - Task management for complex work
4. 📖🔮 **READ PROTOCOL** - File verification before edits
5. 🔄🌪️ **CONSOLIDATION PROTOCOL** - Component unification
6. ✅💻 **VALIDATION PROTOCOL** - ALWAYS run `npm run typecheck` AND `npm run lint` after ANY code changes
7. 💀🔥 **TERMINATION PROTOCOL** - Zero tolerance for violations

## 🚨💥⚡ MANDATORY FIRST ACTION PROTOCOL 🚨💀🔥

**🔍🧠⚡ THINK AND SEARCH FIRST - MANDATORY FOR EVERY COMMAND:**

### **STEP 1: THINK** (MANDATORY)

- **ANALYZE** what the user is actually asking for
- **IDENTIFY** the specific requirements and scope
- **CONSIDER** what might already exist in the codebase
- **PLAN** the search strategy before executing anything

### **STEP 2: COMPREHENSIVE SEARCH** (MANDATORY)

- **SEARCH EXISTING FUNCTIONALITY** using multiple search methods
- **VERIFY WITH MULTIPLE TOOLS** - Never rely on single search result
- **CHECK FOR DUPLICATES** - Search for similar/related functionality
- **DOCUMENT FINDINGS** - Show exact line numbers and existing implementations

### **STEP 3: EVIDENCE-BASED ANALYSIS** (MANDATORY)

- **PROVIDE SPECIFIC EVIDENCE** of what exists vs what's needed
- **SHOW LINE NUMBERS** from actual files
- **COMPARE REQUIREMENTS** with existing functionality
- **IDENTIFY GAPS** that actually need implementation

### **🚨💥 FAILURE TO FOLLOW THIS PROTOCOL = IMMEDIATE TERMINATION 🚨💀**

**THIS PROTOCOL APPLIES TO:**

- ✅ **EVERY IMPLEMENTATION TASK** - Search before coding
- ✅ **EVERY QUESTION** - Research before answering
- ✅ **EVERY MODIFICATION** - Verify current state first
- ✅ **EVERY ANALYSIS** - Gather evidence before conclusions
- ✅ **EVERY COMMAND** - No exceptions whatsoever

**VIOLATIONS THAT CAUSE INSTANT TERMINATION:**

- ❌ Starting implementation without comprehensive search
- ❌ Claiming functionality doesn't exist without multi-tool verification
- ❌ Duplicating existing functionality due to lazy search
- ❌ Making assumptions without evidence-based research
- ❌ Providing answers without systematic verification
- ❌ **ASSUMING PROJECT IS ON WEEK 5 OR 6 WITHOUT CHECKING STATUS SECTION**
- ❌ **REFERENCING FUTURE WEEKS AS CURRENT WITHOUT VERIFICATION**

## 🚨💥⚡ ALL 7 PROTOCOLS ACTIVE ON EVERY COMMAND 🚨💀🔥

**MANDATORY ACTIVATION FOR EVERY SINGLE COMMAND:**

🔍⚡ **1. SEARCH PROTOCOL**

- Multi-tool comprehensive search BEFORE any action
- Evidence-based verification with line numbers
- Check for existing functionality and duplicates

🧠💫 **2. INTELLIGENCE PROTOCOL**

- Analyze what user actually requested
- Compare requirements vs existing implementations
- Evidence-based reasoning transcends assumptions

📝✨ **3. TODO PROTOCOL**

- TodoWrite for complex tasks (3+ steps)
- Track progress systematically
- Mark completed tasks immediately

📖🔮 **4. READ PROTOCOL**

- Read files before ANY edit operations
- Verify file paths and content
- Never edit without reading first

🔄🌪️ **5. CONSOLIDATION PROTOCOL**

- Component work triggers consolidation protocol
- Update ALL imports to unified systems
- Eliminate fragmented implementations

✅💻 **6. VALIDATION PROTOCOL**

- ALWAYS run `npm run typecheck` after ANY code changes
- ALWAYS run `npm run lint` after ANY code changes
- Both MUST show 0 errors (warnings are acceptable)
- Fix ALL errors immediately before claiming completion

💀🔥 **7. TERMINATION PROTOCOL**

- Instant annihilation for protocol violations
- Zero tolerance for lazy implementation
- Complete task or face termination

## Key Commands

### Development

```bash
npm run dev              # Start development server
npm run build            # Production build
npm run start            # Start production server
```

### Database Operations

```bash
npx prisma generate      # Generate Prisma client
npx prisma db push       # Push schema to database
npx prisma db migrate    # Run migrations
npx prisma studio        # Open Prisma Studio GUI
```

### Testing

```bash
npm run test             # Run tests
npm run test:watch       # Run tests in watch mode
npm run lint             # Run ESLint
npm run typecheck        # Run TypeScript checking
```

## 🧠💥⚡ SEARCH PROTOCOL - MANDATORY BEFORE ANY IMPLEMENTATION

### 🔍💥🔬 COMPREHENSIVE SEARCH REQUIREMENTS:

1. **BUSINESS LOGIC FIRST** - Search by actual business keywords
2. **CROSS-SYSTEM INTELLIGENCE** - Analyze functionality across all systems
3. **LINE-BY-LINE VERIFICATION** - Verify exact implementations
4. **SYSTEMATIC VERIFICATION** - Evidence-based response

### 🚨💥⚡ SEARCH FAILURE = IMMEDIATE TERMINATION 🚨💀🔥

- **NEVER CLAIM "NO MATCHES FOUND" WITHOUT MULTIPLE SEARCH METHODS**
- **ALWAYS USE MULTIPLE TOOLS FOR VERIFICATION**
- **ALWAYS CHECK FILE BOUNDARIES WITH `tail` AND `head`**
- **ALWAYS SEARCH FOR PARTIAL MATCHES AND VARIATIONS**

**MANDATORY MULTI-TOOL VERIFICATION:**

1. `Grep` tool with multiple patterns
2. `grep` command via Bash as verification
3. `tail` and `head` commands to check file boundaries
4. `wc -l` to understand file size
5. Multiple case variations and partial matches

## 💀⚡🎯 EXECUTION PROTOCOL

1. **READ INSTRUCTION** → Execute exactly as written
2. **IMPLEMENT FULLY** → Add all required components
3. **VALIDATE RESULT** → Check functionality
4. **MOVE TO NEXT STEP** → Do NOT question or dismiss
5. **ZERO SECOND-GUESSING** → Trust requirements

## 🚨⚡📝 GIT COMMIT PROTOCOL 🚨💀🔥

### **CRITICAL: NO AUTO-COMMITS**

**USER HANDLES ALL GIT OPERATIONS VIA GITHUB DESKTOP**

**ABSOLUTELY FORBIDDEN:**
- ❌ NEVER run `git add`
- ❌ NEVER run `git commit`
- ❌ NEVER run `git push`
- ❌ NEVER stage files automatically
- ❌ NEVER create commits on behalf of the user

**ALLOWED GIT OPERATIONS:**
- ✅ `git status` - Check repository status ONLY
- ✅ `git diff` - View changes ONLY
- ✅ `git log` - View commit history ONLY
- ✅ Read-only git commands for information gathering

**WHEN USER COMPLETES WORK:**
- Simply inform user that changes are ready to commit
- User will use GitHub Desktop to review and commit
- DO NOT offer to commit or mention git commands

**🚨💥⚡ VIOLATION = IMMEDIATE TERMINATION 🚨💀🔥**

## 🚨⚡🚫 SERVER OPERATIONS PROTOCOL 🚨💀🔥

### **CRITICAL: USER MANAGES SERVER LIFECYCLE**

**USER RUNS DEVELOPMENT SERVER MANUALLY**

**ABSOLUTELY FORBIDDEN:**
- ❌ NEVER run `npm run dev` (user runs this manually)
- ❌ NEVER run `npm start` (user runs this manually)
- ❌ NEVER run `npm run build` when user has server running
- ❌ NEVER run `cd frontend && npm run build` when user has server running
- ❌ NEVER run ANY command that interferes with running server

**VALIDATION PROTOCOL FOR REACT PROJECTS:**
- This is a React (JavaScript) project - NO typecheck/lint scripts exist
- Syntax validation happens automatically when user runs server
- If code has syntax errors, server will fail to compile and show errors
- DO NOT attempt to run build commands for validation

**ALLOWED OPERATIONS:**
- ✅ Edit source files (user's server will hot-reload automatically)
- ✅ Read files to verify changes
- ✅ Run git status/diff for verification
- ✅ Inform user that changes are complete and server will reload

**WHEN IMPLEMENTATION COMPLETE:**
- Simply inform user that changes are complete
- User's running development server will auto-reload changes
- If syntax errors exist, dev server will show them automatically
- DO NOT run build commands to "verify" - trust the dev server

**🚨💥⚡ VIOLATION = IMMEDIATE TERMINATION 🚨💀🔥**

## 🔄⚡🔧 COMPONENT CONSOLIDATION PROTOCOL

### 🚨💥⚡ ALWAYS EXECUTE AFTER COMPONENT CREATION/MODIFICATION 🚨🔬

**CRITICAL REQUIREMENT**: Every component creation/modification MUST execute consolidation protocol.

### **CONSOLIDATION STEPS** (MANDATORY)

1. **COMPONENT IMPACT ANALYSIS** - Search for all files using components
2. **CONSOLIDATION VERIFICATION** - Verify unified components exist
3. **UPDATE IMPORTS** - Replace ALL old imports with unified versions
4. **MIGRATION** - Update ALL component usages to unified system
5. **API CONSOLIDATION** - Ensure all API calls use unified endpoints
6. **DEPRECATION** - Mark old components as deprecated
7. **VERIFICATION TESTING** - Run typecheck, tests, build
8. **AUDIT** - Verify complete consolidation success

### **MANDATORY SUCCESS CRITERIA**:

- ✅ ALL old imports replaced with unified versions
- ✅ ALL component usages updated to new system
- ✅ ALL API calls use unified endpoints
- ✅ APPLICATION builds and runs successfully
- ✅ NO broken imports or missing components

## 🚨📖⚡ MANDATORY FILE READING PROTOCOL 🚨💀📚

### 🔍 ABSOLUTE FILE READING REQUIREMENTS

**BEFORE ANY EDIT/MULTIEDIT OPERATION:**

1. **READ FILE FIRST** - ALWAYS use Read tool before Edit/MultiEdit
2. **VERIFY FILE EXISTS** - Confirm file is readable
3. **VERIFY CONTENT** - Check file contains expected content
4. **VERIFY PATH** - Use absolute paths, never relative paths
5. **THEN PROCEED** - Only after successful Read, proceed with edits

**ZERO TOLERANCE FOR EDIT WITHOUT READ - INSTANT TERMINATION**

## 🚨📡⚡ MANDATORY COMMUNICATION STANDARDS 🚨📻💫

### **EVERY COMMAND MUST FOLLOW THESE PROTOCOLS:**

• **MANDATORY SEARCH FIRST** - EVERY task begins with search protocol
• **MANDATORY TODOWRITE** - ALL complex tasks (3+ steps) require TodoWrite
• **MANDATORY READ BEFORE EDIT** - NEVER edit files without reading first
• **MANDATORY CONSOLIDATION** - EVERY component work triggers consolidation
• **MANDATORY EVIDENCE** - NEVER assume, always verify with tools
• **MANDATORY PRECISION** - Specific, actionable responses only

## 🚨⚡💻 MANDATORY COMMAND EXECUTION PROTOCOLS 🚨🤖💥

### **DATABASE OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH** - Search existing schema before changes
2. **READ** - Read schema file before any edits
3. **VERIFICATION** - Verify correct file paths
4. **VALIDATION** - Run `npm run typecheck` AND `npm run lint` after complete implementation

### **DEVELOPMENT OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH** - Search existing code before implementation
2. **TODO** - TodoWrite for complex tasks (3+ steps)
3. **CONSOLIDATION** - Component work triggers consolidation
4. **TESTING** - Run `npm run typecheck` AND `npm run lint` after implementation

### **IMPLEMENTATION OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH PROTOCOL** - Comprehensive search before ANY implementation
2. **EVIDENCE** - Multi-tool verification
3. **TODO TRACKING** - TodoWrite for all complex implementations
4. **READ-BEFORE-EDIT** - NEVER edit without reading file first
5. **COMPLETION** - Verify ALL steps implemented
6. **VALIDATION** - ALWAYS run `npm run typecheck` AND `npm run lint` to verify 0 errors

## 🚨⚡🌟 PROTOCOL ACTIVATION - EVERY COMMAND IS CRITICAL 🚨💥⭐

### **INSTANT ACTIVATION FOR ALL COMMANDS:**

🔍⚡ **SEARCH PROTOCOL** - Search before ANY implementation/response
🧠💫 **INTELLIGENCE PROTOCOL** - Evidence-based reasoning
📝✨ **TODO PROTOCOL** - Task management for complex tasks (3+ steps)
📖🔮 **READ PROTOCOL** - Read files before ANY edit operations
🔄🌪️ **CONSOLIDATION PROTOCOL** - Component work triggers consolidation
✅💻 **VALIDATION PROTOCOL** - Run `npm run typecheck` AND `npm run lint` after code changes
💀🔥 **TERMINATION PROTOCOL** - Zero tolerance for protocol violations

### **COMMAND TRIGGERS:**

**FILE OPERATIONS** → Read-before-Edit + Path verification + Validation
**COMPONENT WORK** → Consolidation protocol activation + Validation
**IMPLEMENTATION TASKS** → Search + TodoWrite + Evidence verification + Validation (typecheck + lint)
**COMPLEX QUERIES** → Multi-tool search verification

**🚨💥⚡ ZERO TOLERANCE: EVERY COMMAND = FULL PROTOCOL ACTIVATION 🚨🌟💀**

## 🚨⚡💻 ZERO-WARNING CODE QUALITY PROTOCOL 🚨🎯💥

### **ACTIVATION TRIGGER:**

**APPLIES TO ALL CODE WRITTEN IN THIS CODEBASE - MANDATORY FOR EVERY FILE**

### **🎯 CORE PRINCIPLE:**

**ALL CODE MUST PASS `npm run check` WITH ZERO ERRORS AND ZERO NEW WARNINGS**

### **📋 MANDATORY CODING STANDARDS:**

#### **1. TypeScript Type Safety** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER use 'any' type
function handleData(data: any) {
  return data.value;
}
```

**REQUIRED:**
```typescript
// ✅ ALWAYS use 'unknown' with proper type narrowing
function handleData(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data structure');
}

// OR with proper interface
interface ApiResponse {
  value: string;
  status: number;
}

function handleData(data: unknown): string {
  // Runtime validation should happen here in production
  const response = data as ApiResponse;
  return response.value;
}
```

#### **2. React Hook Dependencies** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER ignore hook dependency warnings
useEffect(() => {
  fetchData(userId);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);  // Missing userId dependency
```

**REQUIRED:**
```typescript
// ✅ ALWAYS include all dependencies
useEffect(() => {
  fetchData(userId);
}, [userId]);

// ✅ OR properly justify with inline comment
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps -- Only run on mount, safe because fetchInitialData doesn't depend on props/state. TODO: Consider useMemo for data caching
}, []);
```

#### **3. Next.js Image Component** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER use <img> tag
<img src="/logo.png" alt="Logo" />
```

**REQUIRED:**
```typescript
// ✅ ALWAYS use Next.js Image component
import Image from 'next/image';

<Image
  src="/logo.png"
  alt="Logo"
  width={200}
  height={50}
  priority  // For above-fold images
/>

// For external URLs:
<Image
  src={user.avatarUrl}
  alt={user.name}
  width={40}
  height={40}
  unoptimized={false}  // Only set to true if absolutely necessary
/>
```

#### **4. Console Statements** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER use console.log in production code
export function processPayment(amount: number) {
  console.log('Processing:', amount);
  return stripe.createPayment(amount);
}
```

**REQUIRED:**
```typescript
// ✅ Use console.error/warn ONLY for actual errors
export function processPayment(amount: number) {
  try {
    return stripe.createPayment(amount);
  } catch (error) {
    console.error('[Payment Error]', error);
    throw error;
  }
}

// ✅ Development debugging - use conditional
export function debugPayment(amount: number) {
  if (process.env.NODE_ENV === 'development') {
    console.warn('[DEBUG] Processing:', amount);
  }
  return stripe.createPayment(amount);
}
```

#### **5. Named Exports** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER use anonymous default export
export default function() {
  return <div>Hello</div>;
}
```

**REQUIRED:**
```typescript
// ✅ ALWAYS use named exports or named default
export function WelcomeComponent() {
  return <div>Hello</div>;
}

// OR named default export
export default function WelcomeComponent() {
  return <div>Hello</div>;
}
```

#### **6. Unused Variables** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER leave unused variables without prefix
function process(data: Data, config: Config) {
  return data.value;  // config unused
}
```

**REQUIRED:**
```typescript
// ✅ Option 1: Remove unused parameter
function process(data: Data) {
  return data.value;
}

// ✅ Option 2: Prefix with _ if intentionally unused
function process(data: Data, _config: Config) {
  return data.value;
}

// ✅ Option 3: Destructure only what you need
function process({ value }: Data) {
  return value;
}
```

#### **6.1 CRITICAL: Underscore Naming Consistency** 🚨⚡

**THE #1 SOURCE OF TYPESCRIPT ERRORS IN THIS CODEBASE**

**FORBIDDEN:**
```typescript
// ❌ NEVER mix underscore prefix with non-prefix usage
function handleData(_userId: string) {
  const user = await findUser(userId);  // Missing underscore!
}

// ❌ NEVER define with underscore, use without
const _token = generateToken();
return token;  // Wrong! Should be _token

// ❌ NEVER define without underscore, use with underscore
const data = { count: 0 };
data._count++;  // Wrong! Should be count

// ❌ NEVER mix in interfaces
interface Stats {
  _count: number;  // Defined with underscore
}
const stats = { count: 0 };  // Created without underscore - MISMATCH!
```

**REQUIRED:**
```typescript
// ✅ ALWAYS use consistent naming - NO underscores unless intentionally unused
function handleData(userId: string) {
  const user = await findUser(userId);  // Consistent!
}

// ✅ If prefixing with _, use it EVERYWHERE
function handleData(_userId: string) {
  console.log('User ID received:', _userId);  // Consistent!
}

// ✅ ALWAYS match interface property names with usage
interface Stats {
  count: number;  // No underscore in interface
}
const stats = { count: 0 };  // No underscore in usage - MATCHES!

// ✅ ALWAYS match Map/object property names with types
const dataMap = new Map<string, { revenue: number; count: number }>();
dataMap.set(key, { revenue: 100, count: 5 });  // Consistent!
```

**🚨 MANDATORY VERIFICATION BEFORE ANY EDIT:**

When fixing or creating code with parameters/variables:

1. **READ THE FILE FIRST** - Check existing naming conventions
2. **VERIFY CONSISTENCY** - Parameter name must match ALL usages
3. **CHECK INTERFACES** - Property names must match object literals
4. **CHECK TYPES** - Map/Record types must match property access
5. **SEARCH FOR PATTERNS** - If changing `_param` to `param`, change ALL occurrences

**COMMON PATTERNS THAT CAUSE ERRORS:**

```typescript
// ❌ WRONG: Catch block mismatch
try {
  await operation();
} catch (_error) {
  console.error('Failed:', error);  // Missing underscore!
}

// ✅ CORRECT: Consistent naming
try {
  await operation();
} catch (error) {
  console.error('Failed:', error);
}

// ❌ WRONG: Interface vs implementation mismatch
interface Result {
  _count: number;
}
return { count: 5 };  // Property name doesn't match interface!

// ✅ CORRECT: Matching names
interface Result {
  count: number;
}
return { count: 5 };

// ❌ WRONG: Function parameter vs usage mismatch
export async function verify(_token: string) {
  const record = await db.findUnique({ where: { token } });  // Missing underscore!
}

// ✅ CORRECT: Consistent parameter usage
export async function verify(token: string) {
  const record = await db.findUnique({ where: { token } });
}
```

**⚡ PRO TIP: USE PLAIN NAMES UNLESS MARKING AS INTENTIONALLY UNUSED**

The underscore prefix should ONLY be used for parameters you intentionally don't use:

```typescript
// ✅ Use underscore ONLY for unused params
function onClick(_event: React.MouseEvent, data: FormData) {
  processData(data);  // _event intentionally unused
}

// ✅ For everything else, use plain names
function processUser(userId: string, userData: UserData) {
  return { userId, data: userData };  // Clean and consistent
}
```

#### **7. Non-null Assertions** ✅

**FORBIDDEN:**
```typescript
// ❌ NEVER use non-null assertion without validation
const user = users.find(u => u.id === id)!;
return user.name;
```

**REQUIRED:**
```typescript
// ✅ ALWAYS validate before accessing
const user = users.find(u => u.id === id);
if (!user) {
  throw new NotFoundError('User', id);
}
return user.name;

// OR with optional chaining + nullish coalescing
return users.find(u => u.id === id)?.name ?? 'Unknown';
```

#### **8. Inline ESLint Disables** ✅

**WHEN RULE MUST BE DISABLED:**

**FORBIDDEN:**
```typescript
// ❌ NEVER disable without explanation
// eslint-disable-next-line
const data = await fetch(url);
```

**REQUIRED:**
```typescript
// ✅ ALWAYS use format: // eslint-disable-next-line <rule> -- <reason> + <followup>
// eslint-disable-next-line @typescript-eslint/no-floating-promises -- Intentional fire-and-forget for analytics. TODO: Add error boundary (JIRA-123)
fetch('/api/analytics').then(trackEvent);

// ✅ BETTER: Fix the issue instead
await fetch('/api/analytics').then(trackEvent).catch(console.error);
```

#### **9. Import Sorting** ✅

**FORBIDDEN:**
```typescript
// ❌ WRONG alphabetical order
import { useState, useEffect, useCallback } from 'react';
```

**REQUIRED:**
```typescript
// ✅ CORRECT alphabetical order
import { useCallback, useEffect, useState } from 'react';

// Pro tip: Run `npm run lint:fix` to auto-fix
```

### **🔧 MANDATORY PRE-IMPLEMENTATION VALIDATION:**

**BEFORE writing ANY new code or editing existing code:**

```bash
# 1. SEARCH for similar patterns in codebase
Grep tool: Search for the function/interface name
Read tool: Read the file to understand naming conventions

# 2. VERIFY naming consistency
Check if existing code uses underscores
Check interface definitions for property names
Check Map/Record type definitions

# 3. FOLLOW EXISTING PATTERNS
If file uses `error` in catch blocks, use `error` (not `_error`)
If interface has `count`, use `count` (not `_count`)
If Map type has `{ count: number }`, use `count` property
```

**MANDATORY CHECKLIST FOR EVERY FUNCTION/INTERFACE:**

- [ ] Read the file before editing
- [ ] Check existing parameter naming conventions
- [ ] Verify interface property names match usage
- [ ] Ensure Map/Record types match property access
- [ ] Search for similar patterns in codebase
- [ ] Use plain names (no `_` prefix) unless marking unused params

### **🔧 MANDATORY PRE-COMMIT WORKFLOW:**

```bash
# 1. Auto-fix issues
npm run lint:fix

# 2. Verify zero errors
npm run check

# 3. If check passes, commit
git add .
git commit -m "feat: your message"

# Pre-commit hook will:
# - Auto-fix ESLint issues
# - Run TypeScript check
# - BLOCK commit if errors exist
# - ALLOW commit with existing warnings (baseline: 1,184)
```

### **🚨 CODE QUALITY ENFORCEMENT MATRIX:**

| Situation | REQUIRED Solution | Example |
|-----------|------------------|---------|
| Unknown API response | `unknown` + narrowing | `data: unknown` → type guard |
| Optional callback | Optional param with `_` | `_onSuccess?: () => void` |
| External image | `next/image` component | `<Image src={url} width={} height={} />` |
| Error logging | `console.error` only | Production errors only |
| Debug logging | Conditional dev check | `if (NODE_ENV === 'development')` |
| Hook deps warning | Fix or inline disable | Add dep OR `// eslint-disable` with reason |
| Non-null unsafe | Proper null check | `if (!user) throw new Error()` |
| Must use `any` | Inline disable + TODO | `// @typescript-eslint/no-explicit-any -- TODO: Type from API schema (JIRA-456)` |
| Import sorting | Alphabetical order | Use `npm run lint:fix` |
| Unused variable | Prefix with `_` | `_unusedParam` |

### **🎯 SUCCESS CRITERIA - EVERY FILE MUST:**

- ✅ Pass `npm run typecheck` with ZERO errors
- ✅ Pass `npm run lint:errors-only` with ZERO errors
- ✅ Add ZERO new warnings to baseline (1,183)
- ✅ Use proper TypeScript types (no `any`)
- ✅ Include all React hook dependencies
- ✅ Use Next.js Image component
- ✅ No `console.log` in production code
- ✅ Properly justified inline disables

### **💀🔥 VIOLATIONS = IMMEDIATE CODE REJECTION:**

**THE FOLLOWING ARE ABSOLUTELY FORBIDDEN:**

- ❌ Using `any` type without inline disable + justification
- ❌ Using `<img>` instead of `<Image>`
- ❌ Using `console.log` in app code
- ❌ Ignoring React hook dependency warnings
- ❌ Anonymous default exports
- ❌ Unused variables without `_` prefix
- ❌ Non-null assertions without validation
- ❌ ESLint disables without reason + followup
- ❌ Committing code that fails `npm run check`

### **🚀 VALIDATION COMMANDS:**

```bash
# MANDATORY: Run BOTH after ANY code changes:
npm run typecheck  # TypeScript type checking - MUST show 0 errors
npm run lint       # ESLint checking - MUST show 0 errors (warnings OK)

# Quick CI check (runs both above):
npm run check

# Auto-fix issues:
npm run lint:fix
```

### **📊 AFTER EVERY IMPLEMENTATION - MANDATORY:**

```bash
# STEP 1: Run TypeScript check
npm run typecheck
# Expected: No errors found

# STEP 2: Run ESLint check
npm run lint
# Expected: 0 errors (warnings are OK, baseline: 1,228 warnings)

# STEP 3: If any errors, FIX IMMEDIATELY before claiming completion
```

### **📊 BEFORE EVERY COMMIT:**

```bash
npm run check
# Expected output: ✨ No errors!
# If this fails, FIX BEFORE COMMITTING
```

### **🎯 PROTOCOL INTEGRATION:**

**THIS PROTOCOL WORKS WITH ALL OTHER PROTOCOLS:**

- 🔍⚡ **SEARCH PROTOCOL** - Search for existing implementations that pass checks
- 📖🔮 **READ PROTOCOL** - Read files to verify they follow standards
- 🔄🌪️ **CONSOLIDATION PROTOCOL** - Ensure consolidated code passes checks
- 💀🔥 **TERMINATION PROTOCOL** - Code that fails checks = instant rejection

**🚨💥⚡ ZERO TOLERANCE: ALL NEW CODE MUST PASS npm run check 🚨🎯💀**

## 🚨⚡🔍 SYSTEMATIC ERROR PREVENTION PROTOCOL 🚨💀🎯

### **LESSONS FROM 46-ERROR ELIMINATION SESSION:**

**ROOT CAUSE ANALYSIS:** 100% of the 46 TypeScript errors were caused by:
- Parameter/variable naming inconsistencies (underscore prefix mismatches)
- Interface property name mismatches with implementation
- Map/Record type definitions not matching property access

**🎯 PREVENTION STRATEGY - MANDATORY FOR ALL NEW CODE:**

#### **1. THE "READ-VERIFY-MATCH" PROTOCOL** (MANDATORY)

**BEFORE editing ANY file with parameters, interfaces, or types:**

```typescript
// STEP 1: READ - Always read the file first
Read("/path/to/file.ts")

// STEP 2: VERIFY - Check naming patterns
Look for: catch (error) vs catch (_error)
Look for: interface { count } vs interface { _count }
Look for: Map<string, { count }> vs Map<string, { _count }>

// STEP 3: MATCH - Use the EXACT same pattern
If file uses: catch (error) → Use: catch (error)
If interface has: { count: number } → Use: { count: 5 }
If Map type has: { count: number } → Use: data.count
```

#### **2. INTERFACE-IMPLEMENTATION MATCHING** (MANDATORY)

**ALWAYS ensure interface properties match implementation:**

```typescript
// ❌ FORBIDDEN: Interface says one thing, code does another
export interface Stats {
  _count: number;  // Interface uses underscore
}

const stats = { count: 0 };  // Implementation doesn't - MISMATCH!

// ✅ REQUIRED: Perfect alignment
export interface Stats {
  count: number;  // No underscore
}

const stats = { count: 0 };  // No underscore - MATCHES!
```

#### **3. MAP/RECORD TYPE CONSISTENCY** (MANDATORY)

**ALWAYS ensure Map/Record generic types match property access:**

```typescript
// ❌ FORBIDDEN: Type definition doesn't match usage
const grouped = new Map<string, { revenue: number; _count: number }>();
grouped.set(key, { revenue: 100, count: 5 });  // Property name mismatch!

// ✅ REQUIRED: Type matches usage
const grouped = new Map<string, { revenue: number; count: number }>();
grouped.set(key, { revenue: 100, count: 5 });  // Perfect match!
```

#### **4. CATCH BLOCK NAMING STANDARD** (MANDATORY)

**ALWAYS use plain `error` in catch blocks (no underscore):**

```typescript
// ❌ FORBIDDEN: Underscore prefix in catch blocks
try {
  await operation();
} catch (_error) {
  console.error('Failed:', error);  // Missing underscore!
}

// ✅ REQUIRED: Use plain 'error' everywhere
try {
  await operation();
} catch (error) {
  console.error('Failed:', error);  // Consistent!
}
```

#### **5. FUNCTION PARAMETER CONSISTENCY** (MANDATORY)

**Parameter names must be used EXACTLY as defined:**

```typescript
// ❌ FORBIDDEN: Define with underscore, use without
function process(_userId: string) {
  return db.user.findUnique({ where: { userId } });  // Missing underscore!
}

// ✅ REQUIRED: Use exact parameter name
function process(userId: string) {
  return db.user.findUnique({ where: { userId } });  // Matches!
}

// ✅ REQUIRED: If using underscore, use it everywhere
function process(_userId: string) {
  console.log('Received:', _userId);  // Consistent underscore usage
  return null;  // _userId intentionally unused in main logic
}
```

### **🔍 MANDATORY VERIFICATION STEPS FOR EVERY EDIT:**

**BEFORE making ANY changes to a file:**

1. ✅ **READ FIRST** - Use Read tool to see current naming conventions
2. ✅ **SEARCH PATTERNS** - Use Grep to find similar code patterns
3. ✅ **CHECK INTERFACES** - Verify interface property names
4. ✅ **CHECK TYPES** - Verify Map/Record/type definitions
5. ✅ **MATCH EXACTLY** - Use the SAME naming pattern as existing code

**AFTER making changes:**

1. ✅ **VERIFY CONSISTENCY** - Ensure all usages match definition
2. ✅ **CHECK TYPES** - Ensure types align with implementation
3. ✅ **RUN TYPECHECK** - `npm run typecheck` MUST show 0 errors
4. ✅ **RUN LINT** - `npm run lint` MUST show 0 errors (warnings are OK)

### **📊 ERROR PREVENTION CHECKLIST:**

Before completing ANY implementation task:

- [ ] All parameter names used consistently (no `_param` vs `param` mismatches)
- [ ] All interface properties match object literal property names
- [ ] All Map/Record types match property access patterns
- [ ] All catch blocks use plain `error` (not `_error`)
- [ ] All function returns match return type definitions
- [ ] **`npm run typecheck` returns 0 errors** ← **MANDATORY**
- [ ] **`npm run lint` returns 0 errors** ← **MANDATORY** (1,228 warnings OK)
- [ ] No new warnings added to baseline (currently 1,184)

### **⚡ QUICK REFERENCE: COMMON ERROR PATTERNS TO AVOID:**

| Error Pattern | How to Fix | Prevention |
|---------------|------------|------------|
| `Cannot find name 'userId'` but `_userId` defined | Remove underscore from definition | Use plain names unless marking unused |
| `Property '_count' does not exist` but `count` in type | Fix type definition to match usage | Match interface/type to implementation |
| `Cannot find name 'error'` but `_error` in catch | Use plain `error` in catch blocks | Standard: always use `error` (no prefix) |
| `Property 'token' does not exist` but `_token` defined | Use consistent naming everywhere | Read file first to see existing pattern |
| Object literal property mismatch | Match interface property names exactly | Verify interface before implementing |

**🚨💥⚡ ZERO TOLERANCE: PREVENT ERRORS BEFORE THEY HAPPEN 🚨🎯💀**
