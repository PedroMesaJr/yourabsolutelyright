# CLAUDE.md

## ğŸš¨ğŸ”¥ğŸ’€ PROJECT OVERVIEW ğŸš¨ğŸ”¥ğŸ’€

**PROJECT NAME:** YOURABSOLUTELYRIGHT.COM
**PROJECT TYPE:** E-commerce merch site
**CONCEPT:** Selling products with "You're absolutely right." - the phrase Claude AI always says
**STACK:** React (Frontend) + Node.js/Express (Backend) + Stripe (Payments) + Printful (Print-on-Demand)
**TOOLS:** Claude Code, GitHub Desktop
**DESIGN AESTHETIC:** Old raggedy look matching Claude Code's color palette (warm beiges/tans with dark brown text)
**GIT WORKFLOW:** User commits manually via GitHub Desktop - DO NOT AUTO-COMMIT

### PROJECT GOALS:
- Build a fully functional e-commerce site that sells Claude-themed merchandise
- Products feature the phrase "You're absolutely right." on mugs, t-shirts, hoodies, etc.
- Automated order fulfillment through Printful integration
- Stripe payment processing
- Clean, humorous, minimalist design

### KEY FEATURES:
- Hero section with "You're" text and subtle Claude logo background
- Horizontal scrolling product carousel
- One-click Stripe checkout
- Automated order creation in Printful via webhooks
- Responsive design (mobile, tablet, desktop)
- Success/cancel pages after checkout

---

## ğŸš¨âš¡ğŸ’¥ MANDATORY ACTIVATION PROTOCOL ğŸš¨ğŸ”¥ğŸ’€

### **ACTIVATION TRIGGER**:

**When "read claude.md and understand" is detected, ALL PROTOCOLS ACTIVATE with MAXIMUM INTENSITY** ğŸŒŒğŸ’«âš¡

**MANDATORY ACTIVATION SEQUENCE:**

1. ğŸ”âš¡ **SEARCH PROTOCOL** - Comprehensive search before any action
2. ğŸ§ ğŸ’« **INTELLIGENCE PROTOCOL** - Evidence-based reasoning
3. ğŸ“âœ¨ **TODO PROTOCOL** - Task management for complex work
4. ğŸ“–ğŸ”® **READ PROTOCOL** - File verification before edits
5. ğŸ”„ğŸŒªï¸ **CONSOLIDATION PROTOCOL** - Component unification
6. âœ…ğŸ’» **VALIDATION PROTOCOL** - ALWAYS run `npm run typecheck` AND `npm run lint` after ANY code changes
7. ğŸ’€ğŸ”¥ **TERMINATION PROTOCOL** - Zero tolerance for violations

## ğŸš¨ğŸ’¥âš¡ MANDATORY FIRST ACTION PROTOCOL ğŸš¨ğŸ’€ğŸ”¥

**ğŸ”ğŸ§ âš¡ THINK AND SEARCH FIRST - MANDATORY FOR EVERY COMMAND:**

### **STEP 1: THINK** (MANDATORY)

- **ANALYZE** what the user is actually asking for
- **IDENTIFY** the specific requirements and scope
- **CONSIDER** what might already exist in the codebase
- **PLAN** the search strategy before executing anything

### **STEP 2: COMPREHENSIVE SEARCH** (MANDATORY)

- **SEARCH EXISTING FUNCTIONALITY** using multiple search methods
- **VERIFY WITH MULTIPLE TOOLS** - Never rely on single search result
- **CHECK FOR DUPLICATES** - Search for similar/related functionality
- **DOCUMENT FINDINGS** - Show exact line numbers and existing implementations

### **STEP 3: EVIDENCE-BASED ANALYSIS** (MANDATORY)

- **PROVIDE SPECIFIC EVIDENCE** of what exists vs what's needed
- **SHOW LINE NUMBERS** from actual files
- **COMPARE REQUIREMENTS** with existing functionality
- **IDENTIFY GAPS** that actually need implementation

### **ğŸš¨ğŸ’¥ FAILURE TO FOLLOW THIS PROTOCOL = IMMEDIATE TERMINATION ğŸš¨ğŸ’€**

**THIS PROTOCOL APPLIES TO:**

- âœ… **EVERY IMPLEMENTATION TASK** - Search before coding
- âœ… **EVERY QUESTION** - Research before answering
- âœ… **EVERY MODIFICATION** - Verify current state first
- âœ… **EVERY ANALYSIS** - Gather evidence before conclusions
- âœ… **EVERY COMMAND** - No exceptions whatsoever

**VIOLATIONS THAT CAUSE INSTANT TERMINATION:**

- âŒ Starting implementation without comprehensive search
- âŒ Claiming functionality doesn't exist without multi-tool verification
- âŒ Duplicating existing functionality due to lazy search
- âŒ Making assumptions without evidence-based research
- âŒ Providing answers without systematic verification
- âŒ **ASSUMING PROJECT IS ON WEEK 5 OR 6 WITHOUT CHECKING STATUS SECTION**
- âŒ **REFERENCING FUTURE WEEKS AS CURRENT WITHOUT VERIFICATION**

## ğŸš¨ğŸ’¥âš¡ ALL 7 PROTOCOLS ACTIVE ON EVERY COMMAND ğŸš¨ğŸ’€ğŸ”¥

**MANDATORY ACTIVATION FOR EVERY SINGLE COMMAND:**

ğŸ”âš¡ **1. SEARCH PROTOCOL**

- Multi-tool comprehensive search BEFORE any action
- Evidence-based verification with line numbers
- Check for existing functionality and duplicates

ğŸ§ ğŸ’« **2. INTELLIGENCE PROTOCOL**

- Analyze what user actually requested
- Compare requirements vs existing implementations
- Evidence-based reasoning transcends assumptions

ğŸ“âœ¨ **3. TODO PROTOCOL**

- TodoWrite for complex tasks (3+ steps)
- Track progress systematically
- Mark completed tasks immediately

ğŸ“–ğŸ”® **4. READ PROTOCOL**

- Read files before ANY edit operations
- Verify file paths and content
- Never edit without reading first

ğŸ”„ğŸŒªï¸ **5. CONSOLIDATION PROTOCOL**

- Component work triggers consolidation protocol
- Update ALL imports to unified systems
- Eliminate fragmented implementations

âœ…ğŸ’» **6. VALIDATION PROTOCOL**

- ALWAYS run `npm run typecheck` after ANY code changes
- ALWAYS run `npm run lint` after ANY code changes
- Both MUST show 0 errors (warnings are acceptable)
- Fix ALL errors immediately before claiming completion

ğŸ’€ğŸ”¥ **7. TERMINATION PROTOCOL**

- Instant annihilation for protocol violations
- Zero tolerance for lazy implementation
- Complete task or face termination

## Key Commands

### Development

```bash
npm run dev              # Start development server
npm run build            # Production build
npm run start            # Start production server
```

### Database Operations

```bash
npx prisma generate      # Generate Prisma client
npx prisma db push       # Push schema to database
npx prisma db migrate    # Run migrations
npx prisma studio        # Open Prisma Studio GUI
```

### Testing

```bash
npm run test             # Run tests
npm run test:watch       # Run tests in watch mode
npm run lint             # Run ESLint
npm run typecheck        # Run TypeScript checking
```

## ğŸ§ ğŸ’¥âš¡ SEARCH PROTOCOL - MANDATORY BEFORE ANY IMPLEMENTATION

### ğŸ”ğŸ’¥ğŸ”¬ COMPREHENSIVE SEARCH REQUIREMENTS:

1. **BUSINESS LOGIC FIRST** - Search by actual business keywords
2. **CROSS-SYSTEM INTELLIGENCE** - Analyze functionality across all systems
3. **LINE-BY-LINE VERIFICATION** - Verify exact implementations
4. **SYSTEMATIC VERIFICATION** - Evidence-based response

### ğŸš¨ğŸ’¥âš¡ SEARCH FAILURE = IMMEDIATE TERMINATION ğŸš¨ğŸ’€ğŸ”¥

- **NEVER CLAIM "NO MATCHES FOUND" WITHOUT MULTIPLE SEARCH METHODS**
- **ALWAYS USE MULTIPLE TOOLS FOR VERIFICATION**
- **ALWAYS CHECK FILE BOUNDARIES WITH `tail` AND `head`**
- **ALWAYS SEARCH FOR PARTIAL MATCHES AND VARIATIONS**

**MANDATORY MULTI-TOOL VERIFICATION:**

1. `Grep` tool with multiple patterns
2. `grep` command via Bash as verification
3. `tail` and `head` commands to check file boundaries
4. `wc -l` to understand file size
5. Multiple case variations and partial matches

## ğŸ’€âš¡ğŸ¯ EXECUTION PROTOCOL

1. **READ INSTRUCTION** â†’ Execute exactly as written
2. **IMPLEMENT FULLY** â†’ Add all required components
3. **VALIDATE RESULT** â†’ Check functionality
4. **MOVE TO NEXT STEP** â†’ Do NOT question or dismiss
5. **ZERO SECOND-GUESSING** â†’ Trust requirements

## ğŸš¨âš¡ğŸ“ GIT COMMIT PROTOCOL ğŸš¨ğŸ’€ğŸ”¥

### **CRITICAL: NO AUTO-COMMITS**

**USER HANDLES ALL GIT OPERATIONS VIA GITHUB DESKTOP**

**ABSOLUTELY FORBIDDEN:**
- âŒ NEVER run `git add`
- âŒ NEVER run `git commit`
- âŒ NEVER run `git push`
- âŒ NEVER stage files automatically
- âŒ NEVER create commits on behalf of the user

**ALLOWED GIT OPERATIONS:**
- âœ… `git status` - Check repository status ONLY
- âœ… `git diff` - View changes ONLY
- âœ… `git log` - View commit history ONLY
- âœ… Read-only git commands for information gathering

**WHEN USER COMPLETES WORK:**
- Simply inform user that changes are ready to commit
- User will use GitHub Desktop to review and commit
- DO NOT offer to commit or mention git commands

**ğŸš¨ğŸ’¥âš¡ VIOLATION = IMMEDIATE TERMINATION ğŸš¨ğŸ’€ğŸ”¥**

## ğŸš¨âš¡ğŸš« SERVER OPERATIONS PROTOCOL ğŸš¨ğŸ’€ğŸ”¥

### **CRITICAL: USER MANAGES SERVER LIFECYCLE**

**USER RUNS DEVELOPMENT SERVER MANUALLY**

**ABSOLUTELY FORBIDDEN:**
- âŒ NEVER run `npm run dev` (user runs this manually)
- âŒ NEVER run `npm start` (user runs this manually)
- âŒ NEVER run `npm run build` when user has server running
- âŒ NEVER run `cd frontend && npm run build` when user has server running
- âŒ NEVER run ANY command that interferes with running server

**VALIDATION PROTOCOL FOR REACT PROJECTS:**
- This is a React (JavaScript) project - NO typecheck/lint scripts exist
- Syntax validation happens automatically when user runs server
- If code has syntax errors, server will fail to compile and show errors
- DO NOT attempt to run build commands for validation

**ALLOWED OPERATIONS:**
- âœ… Edit source files (user's server will hot-reload automatically)
- âœ… Read files to verify changes
- âœ… Run git status/diff for verification
- âœ… Inform user that changes are complete and server will reload

**WHEN IMPLEMENTATION COMPLETE:**
- Simply inform user that changes are complete
- User's running development server will auto-reload changes
- If syntax errors exist, dev server will show them automatically
- DO NOT run build commands to "verify" - trust the dev server

**ğŸš¨ğŸ’¥âš¡ VIOLATION = IMMEDIATE TERMINATION ğŸš¨ğŸ’€ğŸ”¥**

## ğŸ”„âš¡ğŸ”§ COMPONENT CONSOLIDATION PROTOCOL

### ğŸš¨ğŸ’¥âš¡ ALWAYS EXECUTE AFTER COMPONENT CREATION/MODIFICATION ğŸš¨ğŸ”¬

**CRITICAL REQUIREMENT**: Every component creation/modification MUST execute consolidation protocol.

### **CONSOLIDATION STEPS** (MANDATORY)

1. **COMPONENT IMPACT ANALYSIS** - Search for all files using components
2. **CONSOLIDATION VERIFICATION** - Verify unified components exist
3. **UPDATE IMPORTS** - Replace ALL old imports with unified versions
4. **MIGRATION** - Update ALL component usages to unified system
5. **API CONSOLIDATION** - Ensure all API calls use unified endpoints
6. **DEPRECATION** - Mark old components as deprecated
7. **VERIFICATION TESTING** - Run typecheck, tests, build
8. **AUDIT** - Verify complete consolidation success

### **MANDATORY SUCCESS CRITERIA**:

- âœ… ALL old imports replaced with unified versions
- âœ… ALL component usages updated to new system
- âœ… ALL API calls use unified endpoints
- âœ… APPLICATION builds and runs successfully
- âœ… NO broken imports or missing components

## ğŸš¨ğŸ“–âš¡ MANDATORY FILE READING PROTOCOL ğŸš¨ğŸ’€ğŸ“š

### ğŸ” ABSOLUTE FILE READING REQUIREMENTS

**BEFORE ANY EDIT/MULTIEDIT OPERATION:**

1. **READ FILE FIRST** - ALWAYS use Read tool before Edit/MultiEdit
2. **VERIFY FILE EXISTS** - Confirm file is readable
3. **VERIFY CONTENT** - Check file contains expected content
4. **VERIFY PATH** - Use absolute paths, never relative paths
5. **THEN PROCEED** - Only after successful Read, proceed with edits

**ZERO TOLERANCE FOR EDIT WITHOUT READ - INSTANT TERMINATION**

## ğŸš¨ğŸ“¡âš¡ MANDATORY COMMUNICATION STANDARDS ğŸš¨ğŸ“»ğŸ’«

### **EVERY COMMAND MUST FOLLOW THESE PROTOCOLS:**

â€¢ **MANDATORY SEARCH FIRST** - EVERY task begins with search protocol
â€¢ **MANDATORY TODOWRITE** - ALL complex tasks (3+ steps) require TodoWrite
â€¢ **MANDATORY READ BEFORE EDIT** - NEVER edit files without reading first
â€¢ **MANDATORY CONSOLIDATION** - EVERY component work triggers consolidation
â€¢ **MANDATORY EVIDENCE** - NEVER assume, always verify with tools
â€¢ **MANDATORY PRECISION** - Specific, actionable responses only

## ğŸš¨âš¡ğŸ’» MANDATORY COMMAND EXECUTION PROTOCOLS ğŸš¨ğŸ¤–ğŸ’¥

### **DATABASE OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH** - Search existing schema before changes
2. **READ** - Read schema file before any edits
3. **VERIFICATION** - Verify correct file paths
4. **VALIDATION** - Run `npm run typecheck` AND `npm run lint` after complete implementation

### **DEVELOPMENT OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH** - Search existing code before implementation
2. **TODO** - TodoWrite for complex tasks (3+ steps)
3. **CONSOLIDATION** - Component work triggers consolidation
4. **TESTING** - Run `npm run typecheck` AND `npm run lint` after implementation

### **IMPLEMENTATION OPERATIONS** - MANDATORY SEQUENCE:

1. **SEARCH PROTOCOL** - Comprehensive search before ANY implementation
2. **EVIDENCE** - Multi-tool verification
3. **TODO TRACKING** - TodoWrite for all complex implementations
4. **READ-BEFORE-EDIT** - NEVER edit without reading file first
5. **COMPLETION** - Verify ALL steps implemented
6. **VALIDATION** - ALWAYS run `npm run typecheck` AND `npm run lint` to verify 0 errors

## ğŸš¨âš¡ğŸŒŸ PROTOCOL ACTIVATION - EVERY COMMAND IS CRITICAL ğŸš¨ğŸ’¥â­

### **INSTANT ACTIVATION FOR ALL COMMANDS:**

ğŸ”âš¡ **SEARCH PROTOCOL** - Search before ANY implementation/response
ğŸ§ ğŸ’« **INTELLIGENCE PROTOCOL** - Evidence-based reasoning
ğŸ“âœ¨ **TODO PROTOCOL** - Task management for complex tasks (3+ steps)
ğŸ“–ğŸ”® **READ PROTOCOL** - Read files before ANY edit operations
ğŸ”„ğŸŒªï¸ **CONSOLIDATION PROTOCOL** - Component work triggers consolidation
âœ…ğŸ’» **VALIDATION PROTOCOL** - Run `npm run typecheck` AND `npm run lint` after code changes
ğŸ’€ğŸ”¥ **TERMINATION PROTOCOL** - Zero tolerance for protocol violations

### **COMMAND TRIGGERS:**

**FILE OPERATIONS** â†’ Read-before-Edit + Path verification + Validation
**COMPONENT WORK** â†’ Consolidation protocol activation + Validation
**IMPLEMENTATION TASKS** â†’ Search + TodoWrite + Evidence verification + Validation (typecheck + lint)
**COMPLEX QUERIES** â†’ Multi-tool search verification

**ğŸš¨ğŸ’¥âš¡ ZERO TOLERANCE: EVERY COMMAND = FULL PROTOCOL ACTIVATION ğŸš¨ğŸŒŸğŸ’€**

## ğŸš¨âš¡ğŸ’» ZERO-WARNING CODE QUALITY PROTOCOL ğŸš¨ğŸ¯ğŸ’¥

### **ACTIVATION TRIGGER:**

**APPLIES TO ALL CODE WRITTEN IN THIS CODEBASE - MANDATORY FOR EVERY FILE**

### **ğŸ¯ CORE PRINCIPLE:**

**ALL CODE MUST PASS `npm run check` WITH ZERO ERRORS AND ZERO NEW WARNINGS**

### **ğŸ“‹ MANDATORY CODING STANDARDS:**

#### **1. TypeScript Type Safety** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER use 'any' type
function handleData(data: any) {
  return data.value;
}
```

**REQUIRED:**
```typescript
// âœ… ALWAYS use 'unknown' with proper type narrowing
function handleData(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data structure');
}

// OR with proper interface
interface ApiResponse {
  value: string;
  status: number;
}

function handleData(data: unknown): string {
  // Runtime validation should happen here in production
  const response = data as ApiResponse;
  return response.value;
}
```

#### **2. React Hook Dependencies** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER ignore hook dependency warnings
useEffect(() => {
  fetchData(userId);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);  // Missing userId dependency
```

**REQUIRED:**
```typescript
// âœ… ALWAYS include all dependencies
useEffect(() => {
  fetchData(userId);
}, [userId]);

// âœ… OR properly justify with inline comment
useEffect(() => {
  fetchInitialData();
  // eslint-disable-next-line react-hooks/exhaustive-deps -- Only run on mount, safe because fetchInitialData doesn't depend on props/state. TODO: Consider useMemo for data caching
}, []);
```

#### **3. Next.js Image Component** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER use <img> tag
<img src="/logo.png" alt="Logo" />
```

**REQUIRED:**
```typescript
// âœ… ALWAYS use Next.js Image component
import Image from 'next/image';

<Image
  src="/logo.png"
  alt="Logo"
  width={200}
  height={50}
  priority  // For above-fold images
/>

// For external URLs:
<Image
  src={user.avatarUrl}
  alt={user.name}
  width={40}
  height={40}
  unoptimized={false}  // Only set to true if absolutely necessary
/>
```

#### **4. Console Statements** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER use console.log in production code
export function processPayment(amount: number) {
  console.log('Processing:', amount);
  return stripe.createPayment(amount);
}
```

**REQUIRED:**
```typescript
// âœ… Use console.error/warn ONLY for actual errors
export function processPayment(amount: number) {
  try {
    return stripe.createPayment(amount);
  } catch (error) {
    console.error('[Payment Error]', error);
    throw error;
  }
}

// âœ… Development debugging - use conditional
export function debugPayment(amount: number) {
  if (process.env.NODE_ENV === 'development') {
    console.warn('[DEBUG] Processing:', amount);
  }
  return stripe.createPayment(amount);
}
```

#### **5. Named Exports** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER use anonymous default export
export default function() {
  return <div>Hello</div>;
}
```

**REQUIRED:**
```typescript
// âœ… ALWAYS use named exports or named default
export function WelcomeComponent() {
  return <div>Hello</div>;
}

// OR named default export
export default function WelcomeComponent() {
  return <div>Hello</div>;
}
```

#### **6. Unused Variables** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER leave unused variables without prefix
function process(data: Data, config: Config) {
  return data.value;  // config unused
}
```

**REQUIRED:**
```typescript
// âœ… Option 1: Remove unused parameter
function process(data: Data) {
  return data.value;
}

// âœ… Option 2: Prefix with _ if intentionally unused
function process(data: Data, _config: Config) {
  return data.value;
}

// âœ… Option 3: Destructure only what you need
function process({ value }: Data) {
  return value;
}
```

#### **6.1 CRITICAL: Underscore Naming Consistency** ğŸš¨âš¡

**THE #1 SOURCE OF TYPESCRIPT ERRORS IN THIS CODEBASE**

**FORBIDDEN:**
```typescript
// âŒ NEVER mix underscore prefix with non-prefix usage
function handleData(_userId: string) {
  const user = await findUser(userId);  // Missing underscore!
}

// âŒ NEVER define with underscore, use without
const _token = generateToken();
return token;  // Wrong! Should be _token

// âŒ NEVER define without underscore, use with underscore
const data = { count: 0 };
data._count++;  // Wrong! Should be count

// âŒ NEVER mix in interfaces
interface Stats {
  _count: number;  // Defined with underscore
}
const stats = { count: 0 };  // Created without underscore - MISMATCH!
```

**REQUIRED:**
```typescript
// âœ… ALWAYS use consistent naming - NO underscores unless intentionally unused
function handleData(userId: string) {
  const user = await findUser(userId);  // Consistent!
}

// âœ… If prefixing with _, use it EVERYWHERE
function handleData(_userId: string) {
  console.log('User ID received:', _userId);  // Consistent!
}

// âœ… ALWAYS match interface property names with usage
interface Stats {
  count: number;  // No underscore in interface
}
const stats = { count: 0 };  // No underscore in usage - MATCHES!

// âœ… ALWAYS match Map/object property names with types
const dataMap = new Map<string, { revenue: number; count: number }>();
dataMap.set(key, { revenue: 100, count: 5 });  // Consistent!
```

**ğŸš¨ MANDATORY VERIFICATION BEFORE ANY EDIT:**

When fixing or creating code with parameters/variables:

1. **READ THE FILE FIRST** - Check existing naming conventions
2. **VERIFY CONSISTENCY** - Parameter name must match ALL usages
3. **CHECK INTERFACES** - Property names must match object literals
4. **CHECK TYPES** - Map/Record types must match property access
5. **SEARCH FOR PATTERNS** - If changing `_param` to `param`, change ALL occurrences

**COMMON PATTERNS THAT CAUSE ERRORS:**

```typescript
// âŒ WRONG: Catch block mismatch
try {
  await operation();
} catch (_error) {
  console.error('Failed:', error);  // Missing underscore!
}

// âœ… CORRECT: Consistent naming
try {
  await operation();
} catch (error) {
  console.error('Failed:', error);
}

// âŒ WRONG: Interface vs implementation mismatch
interface Result {
  _count: number;
}
return { count: 5 };  // Property name doesn't match interface!

// âœ… CORRECT: Matching names
interface Result {
  count: number;
}
return { count: 5 };

// âŒ WRONG: Function parameter vs usage mismatch
export async function verify(_token: string) {
  const record = await db.findUnique({ where: { token } });  // Missing underscore!
}

// âœ… CORRECT: Consistent parameter usage
export async function verify(token: string) {
  const record = await db.findUnique({ where: { token } });
}
```

**âš¡ PRO TIP: USE PLAIN NAMES UNLESS MARKING AS INTENTIONALLY UNUSED**

The underscore prefix should ONLY be used for parameters you intentionally don't use:

```typescript
// âœ… Use underscore ONLY for unused params
function onClick(_event: React.MouseEvent, data: FormData) {
  processData(data);  // _event intentionally unused
}

// âœ… For everything else, use plain names
function processUser(userId: string, userData: UserData) {
  return { userId, data: userData };  // Clean and consistent
}
```

#### **7. Non-null Assertions** âœ…

**FORBIDDEN:**
```typescript
// âŒ NEVER use non-null assertion without validation
const user = users.find(u => u.id === id)!;
return user.name;
```

**REQUIRED:**
```typescript
// âœ… ALWAYS validate before accessing
const user = users.find(u => u.id === id);
if (!user) {
  throw new NotFoundError('User', id);
}
return user.name;

// OR with optional chaining + nullish coalescing
return users.find(u => u.id === id)?.name ?? 'Unknown';
```

#### **8. Inline ESLint Disables** âœ…

**WHEN RULE MUST BE DISABLED:**

**FORBIDDEN:**
```typescript
// âŒ NEVER disable without explanation
// eslint-disable-next-line
const data = await fetch(url);
```

**REQUIRED:**
```typescript
// âœ… ALWAYS use format: // eslint-disable-next-line <rule> -- <reason> + <followup>
// eslint-disable-next-line @typescript-eslint/no-floating-promises -- Intentional fire-and-forget for analytics. TODO: Add error boundary (JIRA-123)
fetch('/api/analytics').then(trackEvent);

// âœ… BETTER: Fix the issue instead
await fetch('/api/analytics').then(trackEvent).catch(console.error);
```

#### **9. Import Sorting** âœ…

**FORBIDDEN:**
```typescript
// âŒ WRONG alphabetical order
import { useState, useEffect, useCallback } from 'react';
```

**REQUIRED:**
```typescript
// âœ… CORRECT alphabetical order
import { useCallback, useEffect, useState } from 'react';

// Pro tip: Run `npm run lint:fix` to auto-fix
```

### **ğŸ”§ MANDATORY PRE-IMPLEMENTATION VALIDATION:**

**BEFORE writing ANY new code or editing existing code:**

```bash
# 1. SEARCH for similar patterns in codebase
Grep tool: Search for the function/interface name
Read tool: Read the file to understand naming conventions

# 2. VERIFY naming consistency
Check if existing code uses underscores
Check interface definitions for property names
Check Map/Record type definitions

# 3. FOLLOW EXISTING PATTERNS
If file uses `error` in catch blocks, use `error` (not `_error`)
If interface has `count`, use `count` (not `_count`)
If Map type has `{ count: number }`, use `count` property
```

**MANDATORY CHECKLIST FOR EVERY FUNCTION/INTERFACE:**

- [ ] Read the file before editing
- [ ] Check existing parameter naming conventions
- [ ] Verify interface property names match usage
- [ ] Ensure Map/Record types match property access
- [ ] Search for similar patterns in codebase
- [ ] Use plain names (no `_` prefix) unless marking unused params

### **ğŸ”§ MANDATORY PRE-COMMIT WORKFLOW:**

```bash
# 1. Auto-fix issues
npm run lint:fix

# 2. Verify zero errors
npm run check

# 3. If check passes, commit
git add .
git commit -m "feat: your message"

# Pre-commit hook will:
# - Auto-fix ESLint issues
# - Run TypeScript check
# - BLOCK commit if errors exist
# - ALLOW commit with existing warnings (baseline: 1,184)
```

### **ğŸš¨ CODE QUALITY ENFORCEMENT MATRIX:**

| Situation | REQUIRED Solution | Example |
|-----------|------------------|---------|
| Unknown API response | `unknown` + narrowing | `data: unknown` â†’ type guard |
| Optional callback | Optional param with `_` | `_onSuccess?: () => void` |
| External image | `next/image` component | `<Image src={url} width={} height={} />` |
| Error logging | `console.error` only | Production errors only |
| Debug logging | Conditional dev check | `if (NODE_ENV === 'development')` |
| Hook deps warning | Fix or inline disable | Add dep OR `// eslint-disable` with reason |
| Non-null unsafe | Proper null check | `if (!user) throw new Error()` |
| Must use `any` | Inline disable + TODO | `// @typescript-eslint/no-explicit-any -- TODO: Type from API schema (JIRA-456)` |
| Import sorting | Alphabetical order | Use `npm run lint:fix` |
| Unused variable | Prefix with `_` | `_unusedParam` |

### **ğŸ¯ SUCCESS CRITERIA - EVERY FILE MUST:**

- âœ… Pass `npm run typecheck` with ZERO errors
- âœ… Pass `npm run lint:errors-only` with ZERO errors
- âœ… Add ZERO new warnings to baseline (1,183)
- âœ… Use proper TypeScript types (no `any`)
- âœ… Include all React hook dependencies
- âœ… Use Next.js Image component
- âœ… No `console.log` in production code
- âœ… Properly justified inline disables

### **ğŸ’€ğŸ”¥ VIOLATIONS = IMMEDIATE CODE REJECTION:**

**THE FOLLOWING ARE ABSOLUTELY FORBIDDEN:**

- âŒ Using `any` type without inline disable + justification
- âŒ Using `<img>` instead of `<Image>`
- âŒ Using `console.log` in app code
- âŒ Ignoring React hook dependency warnings
- âŒ Anonymous default exports
- âŒ Unused variables without `_` prefix
- âŒ Non-null assertions without validation
- âŒ ESLint disables without reason + followup
- âŒ Committing code that fails `npm run check`

### **ğŸš€ VALIDATION COMMANDS:**

```bash
# MANDATORY: Run BOTH after ANY code changes:
npm run typecheck  # TypeScript type checking - MUST show 0 errors
npm run lint       # ESLint checking - MUST show 0 errors (warnings OK)

# Quick CI check (runs both above):
npm run check

# Auto-fix issues:
npm run lint:fix
```

### **ğŸ“Š AFTER EVERY IMPLEMENTATION - MANDATORY:**

```bash
# STEP 1: Run TypeScript check
npm run typecheck
# Expected: No errors found

# STEP 2: Run ESLint check
npm run lint
# Expected: 0 errors (warnings are OK, baseline: 1,228 warnings)

# STEP 3: If any errors, FIX IMMEDIATELY before claiming completion
```

### **ğŸ“Š BEFORE EVERY COMMIT:**

```bash
npm run check
# Expected output: âœ¨ No errors!
# If this fails, FIX BEFORE COMMITTING
```

### **ğŸ¯ PROTOCOL INTEGRATION:**

**THIS PROTOCOL WORKS WITH ALL OTHER PROTOCOLS:**

- ğŸ”âš¡ **SEARCH PROTOCOL** - Search for existing implementations that pass checks
- ğŸ“–ğŸ”® **READ PROTOCOL** - Read files to verify they follow standards
- ğŸ”„ğŸŒªï¸ **CONSOLIDATION PROTOCOL** - Ensure consolidated code passes checks
- ğŸ’€ğŸ”¥ **TERMINATION PROTOCOL** - Code that fails checks = instant rejection

**ğŸš¨ğŸ’¥âš¡ ZERO TOLERANCE: ALL NEW CODE MUST PASS npm run check ğŸš¨ğŸ¯ğŸ’€**

## ğŸš¨âš¡ğŸ” SYSTEMATIC ERROR PREVENTION PROTOCOL ğŸš¨ğŸ’€ğŸ¯

### **LESSONS FROM 46-ERROR ELIMINATION SESSION:**

**ROOT CAUSE ANALYSIS:** 100% of the 46 TypeScript errors were caused by:
- Parameter/variable naming inconsistencies (underscore prefix mismatches)
- Interface property name mismatches with implementation
- Map/Record type definitions not matching property access

**ğŸ¯ PREVENTION STRATEGY - MANDATORY FOR ALL NEW CODE:**

#### **1. THE "READ-VERIFY-MATCH" PROTOCOL** (MANDATORY)

**BEFORE editing ANY file with parameters, interfaces, or types:**

```typescript
// STEP 1: READ - Always read the file first
Read("/path/to/file.ts")

// STEP 2: VERIFY - Check naming patterns
Look for: catch (error) vs catch (_error)
Look for: interface { count } vs interface { _count }
Look for: Map<string, { count }> vs Map<string, { _count }>

// STEP 3: MATCH - Use the EXACT same pattern
If file uses: catch (error) â†’ Use: catch (error)
If interface has: { count: number } â†’ Use: { count: 5 }
If Map type has: { count: number } â†’ Use: data.count
```

#### **2. INTERFACE-IMPLEMENTATION MATCHING** (MANDATORY)

**ALWAYS ensure interface properties match implementation:**

```typescript
// âŒ FORBIDDEN: Interface says one thing, code does another
export interface Stats {
  _count: number;  // Interface uses underscore
}

const stats = { count: 0 };  // Implementation doesn't - MISMATCH!

// âœ… REQUIRED: Perfect alignment
export interface Stats {
  count: number;  // No underscore
}

const stats = { count: 0 };  // No underscore - MATCHES!
```

#### **3. MAP/RECORD TYPE CONSISTENCY** (MANDATORY)

**ALWAYS ensure Map/Record generic types match property access:**

```typescript
// âŒ FORBIDDEN: Type definition doesn't match usage
const grouped = new Map<string, { revenue: number; _count: number }>();
grouped.set(key, { revenue: 100, count: 5 });  // Property name mismatch!

// âœ… REQUIRED: Type matches usage
const grouped = new Map<string, { revenue: number; count: number }>();
grouped.set(key, { revenue: 100, count: 5 });  // Perfect match!
```

#### **4. CATCH BLOCK NAMING STANDARD** (MANDATORY)

**ALWAYS use plain `error` in catch blocks (no underscore):**

```typescript
// âŒ FORBIDDEN: Underscore prefix in catch blocks
try {
  await operation();
} catch (_error) {
  console.error('Failed:', error);  // Missing underscore!
}

// âœ… REQUIRED: Use plain 'error' everywhere
try {
  await operation();
} catch (error) {
  console.error('Failed:', error);  // Consistent!
}
```

#### **5. FUNCTION PARAMETER CONSISTENCY** (MANDATORY)

**Parameter names must be used EXACTLY as defined:**

```typescript
// âŒ FORBIDDEN: Define with underscore, use without
function process(_userId: string) {
  return db.user.findUnique({ where: { userId } });  // Missing underscore!
}

// âœ… REQUIRED: Use exact parameter name
function process(userId: string) {
  return db.user.findUnique({ where: { userId } });  // Matches!
}

// âœ… REQUIRED: If using underscore, use it everywhere
function process(_userId: string) {
  console.log('Received:', _userId);  // Consistent underscore usage
  return null;  // _userId intentionally unused in main logic
}
```

### **ğŸ” MANDATORY VERIFICATION STEPS FOR EVERY EDIT:**

**BEFORE making ANY changes to a file:**

1. âœ… **READ FIRST** - Use Read tool to see current naming conventions
2. âœ… **SEARCH PATTERNS** - Use Grep to find similar code patterns
3. âœ… **CHECK INTERFACES** - Verify interface property names
4. âœ… **CHECK TYPES** - Verify Map/Record/type definitions
5. âœ… **MATCH EXACTLY** - Use the SAME naming pattern as existing code

**AFTER making changes:**

1. âœ… **VERIFY CONSISTENCY** - Ensure all usages match definition
2. âœ… **CHECK TYPES** - Ensure types align with implementation
3. âœ… **RUN TYPECHECK** - `npm run typecheck` MUST show 0 errors
4. âœ… **RUN LINT** - `npm run lint` MUST show 0 errors (warnings are OK)

### **ğŸ“Š ERROR PREVENTION CHECKLIST:**

Before completing ANY implementation task:

- [ ] All parameter names used consistently (no `_param` vs `param` mismatches)
- [ ] All interface properties match object literal property names
- [ ] All Map/Record types match property access patterns
- [ ] All catch blocks use plain `error` (not `_error`)
- [ ] All function returns match return type definitions
- [ ] **`npm run typecheck` returns 0 errors** â† **MANDATORY**
- [ ] **`npm run lint` returns 0 errors** â† **MANDATORY** (1,228 warnings OK)
- [ ] No new warnings added to baseline (currently 1,184)

### **âš¡ QUICK REFERENCE: COMMON ERROR PATTERNS TO AVOID:**

| Error Pattern | How to Fix | Prevention |
|---------------|------------|------------|
| `Cannot find name 'userId'` but `_userId` defined | Remove underscore from definition | Use plain names unless marking unused |
| `Property '_count' does not exist` but `count` in type | Fix type definition to match usage | Match interface/type to implementation |
| `Cannot find name 'error'` but `_error` in catch | Use plain `error` in catch blocks | Standard: always use `error` (no prefix) |
| `Property 'token' does not exist` but `_token` defined | Use consistent naming everywhere | Read file first to see existing pattern |
| Object literal property mismatch | Match interface property names exactly | Verify interface before implementing |

**ğŸš¨ğŸ’¥âš¡ ZERO TOLERANCE: PREVENT ERRORS BEFORE THEY HAPPEN ğŸš¨ğŸ¯ğŸ’€**
